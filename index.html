<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Big Bounce (Levels + Characters + Hotseat)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin: 0; background: #111; color: #eee; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .hud { padding: 10px 14px; text-align: center; }
    canvas { display: block; margin: 0 auto; background: #f8fafc; }
    .hint { opacity: 0.85; font-size: 14px; margin-top: 6px; }
    .row { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 10px; }
    button {
      cursor: pointer;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: #fff;
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 600;
    }
    button.active {
      background: rgba(34, 197, 94, 0.22);
      border-color: rgba(34, 197, 94, 0.6);
    }
    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <div class="hud">
    <div><b>Big Bounce</b> — Space/Click to lock <b>Power</b>, then <b>Angle</b>. Move with ← → to catch. Jump with ↑</div>
    <div class="hint">Rules: bounce → wall-face (before roof) → catch. Roof-before-wall = 0. R = reset</div>

    <div class="row">
      <button id="modeSingle">Single Player</button>
      <button id="modeMulti">2P Hotseat (Rounds to 7)</button>
      <button id="btnBegin" disabled>Begin Game</button>
    </div>

    <div class="row">
      <button id="btn0">Map 1: Townhouse</button>
      <button id="btn1">Map 2: Moon</button>
      <button id="btn2">Map 3: Berlin Wall</button>
      <button id="btn3">Map 4: Squash</button>
    </div>

    <div class="row">
      <button id="ch0">Brenden</button>
      <button id="ch1">Ethan</button>
      <button id="ch2">Xavier</button>
      <button id="ch3">Edward</button>
      <button id="ch4">Liam</button>
    </div>

    <div id="status" style="margin-top:10px;"></div>
  </div>

  <canvas id="c" width="1400" height="900"></canvas>

  <script>
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");
    const beginBtn = document.getElementById("btnBegin");

    // -----------------------------
    // World + Layout
    // -----------------------------
    const W = canvas.width;
    const H = canvas.height;

    const PANEL_W = 220;              // LEFT VERTICAL MULTIPLAYER PANEL
    const playLeft = PANEL_W;         // gameplay starts here
    const floorY = H - 20;
    const wallX = W - 140;

    // -----------------------------
    // Single-player run config + timeout
    // -----------------------------
    const SINGLE_TURNS = 10;
    const SINGLE_SHOT_TIMEOUT_S = 8;

    // counts down only for single-player shots while ball is active
    let singleShotTimer = 0;

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    // -----------------------------
    // Popups (big on-screen callouts)
    // -----------------------------
    const popup = {
      text: "",
      color: "#ffffff",
      size: 72,
      timer: 0,
      duration: 1.2
    };

    function showPopup(text, opts = {}) {
      popup.text = text;
      popup.color = opts.color ?? "#ffffff";
      popup.size = opts.size ?? 72;
      popup.duration = opts.duration ?? 1.2;
      popup.timer = popup.duration;
    }

    function updatePopup(dt) {
      if (popup.timer > 0) popup.timer = Math.max(0, popup.timer - dt);
    }

    function drawPopup() {
      if (popup.timer <= 0 || !popup.text) return;

      const t = popup.timer / popup.duration; // 1 -> 0
      const alpha = Math.min(1, Math.max(0, t));

      const cx = playLeft + (W - playLeft) / 2;
      const cy = H * 0.22;

      ctx.save();
      ctx.globalAlpha = 0.15 + 0.85 * alpha;

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = `900 ${popup.size}px Trebuchet MS, system-ui`;

      ctx.lineWidth = 8;
      ctx.strokeStyle = "rgba(0,0,0,0.45)";
      ctx.strokeText(popup.text, cx, cy);

      ctx.fillStyle = popup.color;
      ctx.fillText(popup.text, cx, cy);

      ctx.restore();
    }

    // -----------------------------
    // Level Themes (themed arenas)
    // -----------------------------
    const THEMES = {
      townhouse: {
        bg: "#e5e7eb",
        floor: "#8b5a2b",
        wall: "#f5f5f4",
        roof: "#2a2a2a",
        ui: "#0f172a"
      },
      moon:      { bg: "#0b1020", floor: "#7a7a7a", wall: "#c7c7c7", roof: "#e5e7eb", ui: "#e5e7eb" },
      berlin: {
        bg: "#cfe8f7",
        floor: "#9ca3af",
        wall: "#374151",
        roof: "#000000",
        ui: "#0f172a"
      },
      squash: {
        bg: "#f9f6f1",      // off-white canvas
        floor: "#b45309",   // wood brown
        wall: "#b91c1c",    // scarlet red
        roof: "#7f1d1d",    // dark red ceiling
        ui: "#0f172a"
      }
    };

    // -----------------------------
    // Levels
    // -----------------------------
    const LEVELS = [
      {
        id: 0, name: "Townhouse", roofType: "angled",
        roofLeftY: 450, roofRightY: 120,
        gravity: 1900, restitutionFloor: 0.80, restitutionWall: 0.85, restitutionRoof: 0.55,
        wallTopY: null,
        theme: THEMES.townhouse
      },
      {
        id: 1, name: "Moon", roofType: "none",
        roofY: 110,
        gravity: 700, restitutionFloor: 0.55, restitutionWall: 0.82, restitutionRoof: 0.50,
        wallTopY: null,
        theme: THEMES.moon
      },
      {
        id: 2, name: "Berlin Wall", roofType: "none",
        gravity: 2000, restitutionFloor: 0.88, restitutionWall: 0.87, restitutionRoof: 0.0,
        wallTopY: 0,
        theme: THEMES.berlin
      },
      {
        id: 3,
        name: "Squash",
        roofType: "flat",

        // Ceiling same height as wall
        roofY: 120,

        gravity: 1850,

        // Extra bouncy
        restitutionFloor: 0.95,
        restitutionWall: 0.95,
        restitutionRoof: 0.85,

        wallTopY: 120,

        theme: THEMES.squash
      }
    ];

    const arena = {
      level: null,
      theme: THEMES.townhouse,
      roofType: "none",
      gravity: 1900,
      restitutionFloor: 0.80,
      restitutionWall: 0.85,
      restitutionRoof: 0.55,
      floorFriction: 0.987,
      airDrag: 0.999,
      wallTopY: 0,
      roofY: 0,
      roofLeftY: 0,
      roofRightY: 0
    };

    function roofAtX(x) {
      if (arena.roofType === "none") return -1e9;
      if (arena.roofType === "flat") return arena.roofY;
      const t = clamp((x - playLeft) / (wallX - playLeft), 0, 1);
      return arena.roofLeftY + (arena.roofRightY - arena.roofLeftY) * t;
    }

    // -----------------------------
    // Multiplayer (Hotseat)
    // -----------------------------
    const match = {
      enabled: false,
      started: false,
      roundsToWin: 7,
      roundNum: 1,
      roundStarter: 0,
      activeIndex: 0,
      winnerIndex: null,
      roundShots: [null, null],
      setupPickIndex: 0,
      firstPlayerScoredZeroThisRound: false,
      players: [
        { name: "P1", characterId: null, roundsWon: 0, lastThrow: null, throws: 0, sum: 0, walmart100s: 0, layups: 0, attempts: 0, catches: 0, best: null },
        { name: "P2", characterId: null, roundsWon: 0, lastThrow: null, throws: 0, sum: 0, walmart100s: 0, layups: 0, attempts: 0, catches: 0, best: null }
      ]
    };

    function resetPlayerStats(p) {
      p.throws = 0; p.sum = 0; p.walmart100s = 0; p.layups = 0; p.attempts = 0; p.catches = 0; p.best = null; p.lastThrow = null;
    }

    function canBeginGame() {
      if (!match.enabled) return false;
      const okLevel = !!arena.level;
      const okChars = match.players[0].characterId != null && match.players[1].characterId != null;
      return okLevel && okChars && !match.started;
    }

    function refreshBeginButton() {
      beginBtn.disabled = !canBeginGame();
      beginBtn.classList.toggle("active", canBeginGame());
    }

    function beginGame() {
      if (!canBeginGame()) return;
      match.started = true;

      match.roundNum = 1;
      match.roundStarter = 0;
      match.activeIndex = match.roundStarter;
      match.winnerIndex = null;
      match.roundShots = [null, null];
      match.firstPlayerScoredZeroThisRound = false;

      match.players[0].roundsWon = 0; match.players[1].roundsWon = 0;
      resetPlayerStats(match.players[0]);
      resetPlayerStats(match.players[1]);

      setCurrentCharacterForTurn();
      startNewShot();
      state = State.POWER_METER;
      updateStatus("Game started! P1 lock POWER.");
      refreshBeginButton();
    }

    beginBtn.onclick = beginGame;

    // -----------------------------
    // Characters (5-tier) + Outfits
    // -----------------------------
    const TIER_MULT = Object.freeze({ 1: 0.7, 2: 0.85, 3: 1.00, 4: 1.15, 5: 1.3 });
    const CATCH_W_MULT = Object.freeze({ 1: 0.85, 2: 0.95, 3: 1.05, 4: 1.05, 5: 1.15 });

    const CHAR_COLORS = Object.freeze({
      Brenden: "#f59e0b",
      Xavier:  "#3b82f6",
      Liam:    "#22c55e",
      Edward:  "#ef4444",
      Ethan:   "#facc15"
    });

    // NEW: layered outfits (pants 35%, shirt 30%, face 25%, hair 10%)
    const DEFAULT_OUTFIT = {
      hair: "#3f3f46",
      face: "#fde68a",
      shirt: "#22c55e",
      pants: "#1e293b",
      outline: "#111827"
    };

const CHAR_OUTFITS = Object.freeze({
  // Xavier: Hair dark brown, Shirt white, Pants dark blue
  Xavier:  { hair:"#3b2f2f", face:"#fde68a", shirt:"#ffffff", pants:"#1e3a8a", outline:"#111827" },

  // Brenden: Hair orange, Shirt light blue, Pants dark blue
  Brenden: { hair:"#f97316", face:"#fde68a", shirt:"#93c5fd", pants:"#1e3a8a", outline:"#111827" },

  // Ethan: Hair brown, Shirt green, Pants black
  Ethan:   { hair:"#8b5e34", face:"#fef3c7", shirt:"#22c55e", pants:"#000000", outline:"#111827" },

  // Edward: Hair brown, Shirt red, Pants tan
  Edward:  { hair:"#8b5e34", face:"#fee2e2", shirt:"#ef4444", pants:"#d2b48c", outline:"#111827" },

  // Liam: Hair black, Shirt blue, Pants camel
  Liam:    { hair:"#000000", face:"#fef3c7", shirt:"#3b82f6", pants:"#c19a6b", outline:"#111827" }
});

    const CHARACTERS = [
      { id: 0, name: "Brenden", tiers: { control: 2, accuracy: 1, speed: 5, catching: 4 } },
      { id: 1, name: "Ethan",   tiers: { control: 1, accuracy: 2, speed: 4, catching: 5 } },
      { id: 2, name: "Xavier",  tiers: { control: 5, accuracy: 4, speed: 1, catching: 2 } },
      { id: 3, name: "Edward",  tiers: { control: 4, accuracy: 5, speed: 2, catching: 1 } },
      { id: 4, name: "Liam",    tiers: { control: 3, accuracy: 3, speed: 3, catching: 3 } }
    ].map(c => ({
      ...c,
      // keep color available for future UI ideas, but drawing now uses outfit
      color: CHAR_COLORS[c.name] ?? "#d9f7d0",
      outfit: CHAR_OUTFITS[c.name] ?? DEFAULT_OUTFIT,
      stats: {
        control:  TIER_MULT[c.tiers.control],
        accuracy: TIER_MULT[c.tiers.accuracy],
        speed:    TIER_MULT[c.tiers.speed],
        catchingWidth: CATCH_W_MULT[c.tiers.catching]
      }
    }));

    let currentCharacter = CHARACTERS[0];

    function updateCharacterButtons() {
      const activeCharId = match.enabled
        ? (match.started ? match.players[match.activeIndex].characterId : match.players[match.setupPickIndex].characterId)
        : currentCharacter.id;

      for (let i = 0; i < CHARACTERS.length; i++) {
        document.getElementById("ch" + i).classList.toggle("active", i === activeCharId);
      }
    }

    function setCurrentCharacterForTurn() {
      if (!match.enabled) return;
      const cid = match.players[match.activeIndex].characterId;
      currentCharacter = CHARACTERS[cid ?? 0];
      updateCharacterButtons();
    }

    function applyCharacter(charIndex) {
      if (match.enabled && match.started) return;

      if (match.enabled) {
        match.players[match.setupPickIndex].characterId = charIndex;
        const cid = match.players[match.setupPickIndex].characterId;
        currentCharacter = CHARACTERS[cid ?? 0];

        updateCharacterButtons();
        updateStatus(`Assigned ${currentCharacter.name} to P${match.setupPickIndex + 1}`);
        refreshBeginButton();
      } else {
        currentCharacter = CHARACTERS[charIndex];
        updateCharacterButtons();
        updateStatus(`Character: ${currentCharacter.name}`);
      }
    }

    document.getElementById("ch0").onclick = () => applyCharacter(0);
    document.getElementById("ch1").onclick = () => applyCharacter(1);
    document.getElementById("ch2").onclick = () => applyCharacter(2);
    document.getElementById("ch3").onclick = () => applyCharacter(3);
    document.getElementById("ch4").onclick = () => applyCharacter(4);

    // -----------------------------
    // Level selection
    // -----------------------------
    function applyLevel(levelIndex) {
      if (match.enabled && match.started) return;

      const L = LEVELS[levelIndex];
      arena.level = L;
      arena.theme = L.theme || THEMES.townhouse;

      arena.roofType = L.roofType;
      arena.gravity = L.gravity;
      arena.restitutionFloor = L.restitutionFloor;
      arena.restitutionWall = L.restitutionWall;
      arena.restitutionRoof = L.restitutionRoof;

      if (L.roofType === "flat") {
        arena.roofY = L.roofY;
      } else if (L.roofType === "angled") {
        arena.roofLeftY = L.roofLeftY;
        arena.roofRightY = L.roofRightY;
      }

      if (L.id === 0) {
        arena.wallTopY = clamp(roofAtX(wallX), 0, floorY - 40);
      } else if (L.id === 1) {
        arena.wallTopY = 0;
      } else {
        arena.wallTopY = clamp(L.wallTopY, 0, floorY - 40);
      }

      for (let i = 0; i < 4; i++) {
        document.getElementById("btn" + i).classList.toggle("active", i === levelIndex);
      }

      startNewShot();
      state = State.POWER_METER;
      updateStatus(`Selected: ${L.name}. Lock POWER.`);
      refreshBeginButton();
    }

    document.getElementById("btn0").onclick = () => applyLevel(0);
    document.getElementById("btn1").onclick = () => applyLevel(1);
    document.getElementById("btn2").onclick = () => applyLevel(2);
    document.getElementById("btn3").onclick = () => applyLevel(3);

    // -----------------------------
    // Mode
    // -----------------------------
    function setMode(isMulti) {
      match.enabled = isMulti;
      match.started = false;

      document.getElementById("modeSingle").classList.toggle("active", !isMulti);
      document.getElementById("modeMulti").classList.toggle("active", isMulti);

      match.roundNum = 1;
      match.roundStarter = 0;
      match.activeIndex = 0;
      match.winnerIndex = null;
      match.roundShots = [null, null];
      match.setupPickIndex = 0;
      match.firstPlayerScoredZeroThisRound = false;

      match.players[0].roundsWon = 0; match.players[1].roundsWon = 0;

      resetSingleStats();
      resetPlayerStats(match.players[0]);
      resetPlayerStats(match.players[1]);

      if (isMulti) {
        if (match.players[0].characterId == null) match.players[0].characterId = 0;
        if (match.players[1].characterId == null) match.players[1].characterId = 1;
        currentCharacter = CHARACTERS[match.players[0].characterId] ?? CHARACTERS[0];
      } else {
        currentCharacter = CHARACTERS[0];
      }

      updateCharacterButtons();
      resetGame();
      refreshBeginButton();
      updateStatus(isMulti ? "2P Hotseat: pick a level, assign chars to P1/P2, then Begin Game." : "Single Player: pick a level.");
    }

    document.getElementById("modeSingle").onclick = () => setMode(false);
    document.getElementById("modeMulti").onclick  = () => setMode(true);

    // -----------------------------
    // Player + Glove + Jump (↑)
    // -----------------------------
    const player = {
      x: playLeft + 20,
      y: 0,
      w: 80,
      h: 110,
      baseSpeed: 720,
      vy: 0
    };

    function groundY() { return floorY - player.h; }

    function isPlayerGrounded() {
      return player.y >= groundY() - 0.5 && Math.abs(player.vy) < 0.01;
    }

    function jumpImpulse() {
      const jumpH = player.h * 0.9;
      return Math.sqrt(2 * arena.gravity * jumpH);
    }

    function attemptJump() {
      if (state === State.TITLE || state === State.MATCH_OVER || state === State.SINGLE_OVER) return;
      if (!arena.level) return;
      if (match.enabled && !match.started) return;

      if (isPlayerGrounded()) player.vy = -jumpImpulse();
    }

    function getHandsRect() {
      let hw = Math.round(player.w * 0.55);
      let hh = Math.round(player.h * 0.22);

      const catchMul = currentCharacter?.stats?.catchingWidth ?? 1;
      hw = Math.round(hw * catchMul);

      const offsetX = Math.round(player.w * 0.10);
      const hx = player.x + player.w + offsetX;
      const hy = player.y + Math.round(player.h * 0.35);

      return { x: hx, y: hy, w: hw, h: hh };
    }

    // -----------------------------
    // Ball
    // -----------------------------
    const ball = { r: 12, x: 0, y: 0, vx: 0, vy: 0, active: false };

    // -----------------------------
    // State machine
    // -----------------------------
    const State = Object.freeze({
      TITLE: "TITLE",
      SELECT_LEVEL: "SELECT_LEVEL",
      POWER_METER: "POWER_METER",
      ANGLE_METER: "ANGLE_METER",
      FLIGHT: "FLIGHT",
      RETURNING: "RETURNING",
      MATCH_OVER: "MATCH_OVER",
      SINGLE_OVER: "SINGLE_OVER"
    });
    let state = State.TITLE;

    // -----------------------------
    // Timing meter
    // -----------------------------
    const meter = {
      value: 0.0,
      dir: 1,
      basePowerSpeed: 1.35,
      baseAngleSpeed: 1.35,
      lockedPower: null,
      lockedAngleRad: null
    };

    function effectivePowerSpeed() {
      const c = currentCharacter?.stats?.control ?? 1;
      return meter.basePowerSpeed / c;
    }
    function effectiveAngleSpeed() {
      const a = currentCharacter?.stats?.accuracy ?? 1;
      return meter.baseAngleSpeed / a;
    }

    // -----------------------------
    // Shot context
    // -----------------------------
    function newShotContext() {
      return {
        bouncedBeforeWall: false,
        hitWall: false,
        hitRoofBeforeWall: false,
        wallHitY: null,
        pendingPoints: 0,
        invalid: false,
        invalidReason: "",
        popupCeilingShown: false
      };
    }
    let shot = newShotContext();

    // -----------------------------
    // Stats (Single + Multiplayer)
    // -----------------------------
    let lastThrowPoints = null;
    let lastWallHitY = null;

    const singleStats = {
      throws: 0,
      sum: 0,
      walmart100s: 0,
      layups: 0,
      attempts: 0,
      catches: 0,
      best: null
    };

    function resetSingleStats() {
      singleStats.throws = 0;
      singleStats.sum = 0;
      singleStats.walmart100s = 0;
      singleStats.layups = 0;
      singleStats.attempts = 0;
      singleStats.catches = 0;
      singleStats.best = null;
    }

    function avgScore(stats) { return stats.throws > 0 ? (stats.sum / stats.throws) : 0; }
    function catchPct(stats) { return stats.attempts > 0 ? (stats.catches / stats.attempts) : 0; }

    // -----------------------------
    // Scoring helper
    // -----------------------------
    function scoreFromWallHit(yHit) {
      const top = arena.wallTopY + ball.r;
      const bottom = floorY - ball.r;

      const clampedY = clamp(yHit, top, bottom);
      const height = bottom - clampedY;
      const maxHeight = bottom - top;

      const raw = 1 + (99 * (height / maxHeight));
      return clamp(Math.round(raw), 1, 100);
    }

    function tiersTextFor(charObj) {
      const t = charObj?.tiers;
      if (!t) return "";
      return `C${t.control} A${t.accuracy} S${t.speed} H${t.catching}`;
    }

    function updateStatus(extra = "") {
      const lvl = arena.level ? ` | Level: ${arena.level.name}` : "";
      if (!match.enabled) {
        const last = (lastThrowPoints == null) ? "" : ` | Last: ${lastThrowPoints}`;
        const inv = shot?.invalid ? ` | INVALID: ${shot.invalidReason}` : "";
        const ch = currentCharacter ? ` | Char: ${currentCharacter.name} (${tiersTextFor(currentCharacter)})` : "";

        const avg = avgScore(singleStats);
        const best = singleStats.best ?? "-";
        const pct = Math.round(catchPct(singleStats) * 100);
        const w100 = singleStats.walmart100s;

        statusEl.textContent =
          `Avg: ${avg.toFixed(1)} | Best: ${best} | Catch%: ${pct}% | Walmart100s: ${w100}` +
          `${last}${inv}${lvl}${ch}${extra ? " — " + extra : ""}`;
      } else {
        const turn = match.started ? ` | Turn: P${match.activeIndex + 1}` : ` | Setup: click P1/P2 in panel`;
        statusEl.textContent = `2P Hotseat (to ${match.roundsToWin}) | Round ${match.roundNum}${lvl}${turn}${extra ? " — " + extra : ""}`;
      }
    }

    // -----------------------------
    // Helper: end the run (Single Over)
    // -----------------------------
    function endSingleRun() {
      state = State.SINGLE_OVER;
      singleShotTimer = 0;
      updateStatus("RUN OVER");
    }

    function singleRunIsOver() {
      return singleStats.attempts >= SINGLE_TURNS && singleStats.throws >= SINGLE_TURNS;
    }

    // -----------------------------
    // Input
    // -----------------------------
    const keys = {};
    window.addEventListener("keydown", (e) => {
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(e.key) || e.code === "Space") e.preventDefault();

      const wasDown = !!keys[e.key];
      keys[e.key] = true;

      if (e.key.toLowerCase() === "r") resetGame();
      if (e.key === " " || e.code === "Space") handleAction();

      if (!wasDown && e.key === "ArrowUp") attemptJump();
    }, { passive: false });

    window.addEventListener("keyup", (e) => {
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(e.key) || e.code === "Space") e.preventDefault();
      keys[e.key] = false;
    }, { passive: false });

    canvas.addEventListener("mousedown", () => handleAction());

    // -----------------------------
    // Crater helper (Moon)
    // -----------------------------
    function drawCraters(color, count, area) {
      ctx.fillStyle = color;

      for (let i = 0; i < count; i++) {
        const r = 6 + Math.random() * 18;

        let x, y;

        if (area === "floor") {
          x = playLeft + Math.random() * (W - playLeft - 40);
          y = floorY - Math.random() * 40;
        } else {
          x = wallX + Math.random() * (W - wallX - 20);
          y = arena.wallTopY + Math.random() * (floorY - arena.wallTopY - 40);
        }

        ctx.beginPath();
        ctx.globalAlpha = 0.35;
        ctx.ellipse(x, y, r * 1.2, r, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    // -----------------------------
    // Concrete texture helper (Berlin)
    // -----------------------------
    function drawConcreteTexture(x, y, w, h) {
      ctx.strokeStyle = "rgba(0,0,0,0.08)";
      ctx.lineWidth = 1;

      for (let i = 0; i < 120; i++) {
        const px = x + Math.random() * w;
        const py = y + Math.random() * h;

        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(px + Math.random() * 6, py + Math.random() * 6);
        ctx.stroke();
      }
    }

    // -----------------------------
    // Helpers
    // -----------------------------
    function rectsOverlap(a, b) {
      return a.x < b.x + b.w && a.x + a.w > b.x &&
             a.y < b.y + b.h && a.y + a.h > b.y;
    }

    function resetBallToHand() {
      const hands = getHandsRect();
      ball.active = false;
      ball.vx = 0;
      ball.vy = 0;
      ball.x = hands.x + hands.w * 0.35;
      ball.y = hands.y + hands.h * 0.55;
    }

    function resetMeters() {
      meter.value = 0.0;
      meter.dir = 1;
      meter.lockedPower = null;
      meter.lockedAngleRad = null;
    }

    function startNewShot() {
      shot = newShotContext();
      resetMeters();
      resetBallToHand();
      singleShotTimer = 0;
      state = arena.level ? State.POWER_METER : State.SELECT_LEVEL;
      updateStatus(arena.level ? "Ready: lock POWER." : "Select a level to begin.");
    }

    function resetGame() {
      lastThrowPoints = null;
      lastWallHitY = null;

      resetSingleStats();
      resetPlayerStats(match.players[0]);
      resetPlayerStats(match.players[1]);

      match.winnerIndex = null;
      match.roundNum = 1;
      match.roundStarter = 0;
      match.activeIndex = 0;
      match.roundShots = [null, null];
      match.firstPlayerScoredZeroThisRound = false;

      match.players[0].roundsWon = 0; match.players[1].roundsWon = 0;

      if (match.enabled) match.started = false;

      player.x = playLeft + 20;
      player.y = groundY();
      player.vy = 0;

      if (match.enabled) {
        match.setupPickIndex = 0;
        currentCharacter = CHARACTERS[match.players[0].characterId ?? 0];
      }

      startNewShot();
      refreshBeginButton();
      updateStatus(match.enabled ? "2P reset. Pick a level, assign chars, Begin Game." : "Reset. Select a level.");
    }

    // -----------------------------
    // Meter logic
    // -----------------------------
    function meterStep(dt, speed) {
      meter.value += meter.dir * speed * dt;
      if (meter.value >= 1) { meter.value = 1; meter.dir = -1; }
      if (meter.value <= 0) { meter.value = 0; meter.dir = 1; }
    }

    // -----------------------------
    // Actions
    // -----------------------------
    function startFromTitle() {
      state = State.SELECT_LEVEL;
      updateStatus(match.enabled ? "Pick a level, assign chars, then Begin Game." : "Pick a level to begin.");
      refreshBeginButton();
    }

    function handleAction() {
      if (state === State.TITLE) { startFromTitle(); return; }

      if (state === State.MATCH_OVER) return;
      if (state === State.SELECT_LEVEL) return;
      if (!arena.level) return;

      if (state === State.SINGLE_OVER) return;

      if (!match.enabled && singleStats.attempts >= SINGLE_TURNS) {
        endSingleRun();
        return;
      }

      if (match.enabled && !match.started) return;

      if (state === State.POWER_METER) {
        meter.lockedPower = meter.value;
        state = State.ANGLE_METER;

        meter.value = 0.5;
        meter.dir = (Math.random() < 0.5) ? -1 : 1;

        updateStatus("Power locked. Lock ANGLE.");
        return;
      }

      if (state === State.ANGLE_METER) {
        const minDeg = -90;
        const maxDeg = -60;
        const deg = minDeg + (maxDeg - minDeg) * meter.value;
        meter.lockedAngleRad = (deg * Math.PI) / 180;

        launchBall();
        return;
      }
    }

    function launchBall() {
      const p = meter.lockedPower ?? 0.5;

      const minSpeed = 950;
      const maxSpeed = 2200;
      const speed = minSpeed + (maxSpeed - minSpeed) * p;

      const a = meter.lockedAngleRad ?? (-75 * Math.PI / 180);

      resetBallToHand();
      ball.active = true;

      if (match.enabled) match.players[match.activeIndex].attempts++;
      else singleStats.attempts++;

      if (!match.enabled) singleShotTimer = SINGLE_SHOT_TIMEOUT_S;

      const vxRaw = Math.cos(a) * speed;
      ball.vx = Math.max(160, vxRaw);
      ball.vy = -Math.sin(a) * speed;

      shot = newShotContext();
      state = State.FLIGHT;
      updateStatus("Ball in flight.");
    }

    // ... rest of your original file unchanged ...
  </script>
</body>
</html>
